<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.324">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brandon Scott">
<meta name="dcterms.date" content="2025-06-19">

<title>The Bayesian Bandit - Optimizing Optimization: A Tutorial on Dispatch Algorithms with Applications in the Gig Economy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">The Bayesian Bandit</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://thebayesianbandit.com/causal_book/" rel="" target="">
 <span class="menu-text">Book</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/thebayesianbandit" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/brandon-scott-5a7139211/" rel="" target=""><i class="bi bi-linkedin" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Optimizing Optimization: A Tutorial on Dispatch Algorithms with Applications in the Gig Economy</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">operations</div>
                <div class="quarto-category">optimization</div>
                <div class="quarto-category">python</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Brandon Scott </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">June 19, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#designing-the-problem-via-control" id="toc-designing-the-problem-via-control" class="nav-link" data-scroll-target="#designing-the-problem-via-control">Designing the Problem via Control</a>
  <ul class="collapse">
  <li><a href="#whats-the-system" id="toc-whats-the-system" class="nav-link" data-scroll-target="#whats-the-system">What’s the system?</a></li>
  <li><a href="#what-should-we-feedback" id="toc-what-should-we-feedback" class="nav-link" data-scroll-target="#what-should-we-feedback">What should we feedback?</a></li>
  <li><a href="#what-actions-can-we-take-to-adjust-the-system" id="toc-what-actions-can-we-take-to-adjust-the-system" class="nav-link" data-scroll-target="#what-actions-can-we-take-to-adjust-the-system">What actions can we take to adjust the system?</a></li>
  </ul></li>
  <li><a href="#establishing-operations" id="toc-establishing-operations" class="nav-link" data-scroll-target="#establishing-operations">Establishing Operations</a>
  <ul class="collapse">
  <li><a href="#current-approach-bipartite-matching" id="toc-current-approach-bipartite-matching" class="nav-link" data-scroll-target="#current-approach-bipartite-matching">Current approach: bipartite matching</a></li>
  <li><a href="#an-example-via-queue-theory" id="toc-an-example-via-queue-theory" class="nav-link" data-scroll-target="#an-example-via-queue-theory">An example via queue theory</a></li>
  </ul></li>
  <li><a href="#optimizing-dispatch-using-integer-programming" id="toc-optimizing-dispatch-using-integer-programming" class="nav-link" data-scroll-target="#optimizing-dispatch-using-integer-programming">Optimizing Dispatch using Integer Programming</a></li>
  <li><a href="#simulation-results" id="toc-simulation-results" class="nav-link" data-scroll-target="#simulation-results">Simulation Results</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>In this post, we present an implementation for <em>Next-Generation Optimization for Dasher Dispatch at DoorDash</em> <span class="citation" data-cites="doordash_optimization_2020"><a href="#ref-doordash_optimization_2020" role="doc-biblioref">[1]</a></span> and <em>Using ML and Optimization to Solve DoorDash’s Dispatch Problem</em> <span class="citation" data-cites="weinstein_ml_optimization_2021"><a href="#ref-weinstein_ml_optimization_2021" role="doc-biblioref">[2]</a></span>. We demonstrate this implementation in the context of a smaller, simpler food delivery system. We conclude by presenting some simple sensitivity analysis from changes in our hyperparameters weights in our scoring methods. The code for this simulation can be found at the <a href="https://github.com/thebayesianbandit/thebayesianbandit.github.io/blob/main/posts/dispatch_alg/dispatch_alg.ipynb">github repo</a>.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p><strong>Food-Ez</strong> is a new food delivery service specializing in delivering foods in small, walkable cities. Like other companies like DoorDash and UberEats, Food-Ez is a three sided marketplace, dealing with the needs and wants of customers (those who place the orders), restaurants (those who create the orders), and deliverers (those who fulfill the orders). Understanding this, Food-Ez developed a novel dispatch algorithm to maximize efficiency in their marketplace. Specifically, they created an algorithm that minimized delivery time by matching orders to the driver who is the closest to the restaurant. While this approach has been effective for Food-Ez, they are looking to upgrade their current algorithm in a few ways. First, they are <strong>allowing deliverers to be assigned up to 2 orders at a time now</strong>. Second, they want to have more efficient operations. Their current algorithm has drivers waiting quite a bit of time for food to be prepped at restaurants. They want to <strong>maximize deliverer efficiency by minimizing driver wait and idle time</strong>.</p>
</section>
<section id="designing-the-problem-via-control" class="level1">
<h1>Designing the Problem via Control</h1>
<p>Before going into the details of how each algorithm operates within this problem, we first present how to design the problem in a way to reach optimal solutions. One way to approach this problem is by viewing it as a <strong>control problem</strong>. Control theory offers a rich framework by which we can design our problem and subsequent solutions. In essence, control theory aims to stabilize/optimize some system that we’ll donate as <span class="math inline">\(P\)</span> (commonly known as the Plant). The system creates outputs that include feedback signals that are fed back to a <strong>controller</strong> that we’ll denote as <span class="math inline">\(C\)</span>. <a href="#fig-control-diag">Figure&nbsp;3.1</a> is an example control diagram.</p>
<div id="fig-control-diag" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="http://www.polytechnichub.com/wp-content/uploads/2017/04/closed_loop.jpg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;3.1: An example control diagram</figcaption><p></p>
</figure>
</div>
<p>Control theory excels at helping us model dynamical systems and how we can control said systems even in the face of uncertainty (i.e.&nbsp;not knowing all the dynamics of the system). In our scenario specifically, the delivery marketplace is a very dynamic system. Orders come in at different waves at different locations with an unknown supply of drivers to deliver said orders. With control theory, we can boil down this complex problem into essentially three parts: First, what is the system we are trying to control? Second, what information can we gain from the system? Third, what actions can we take to ensure the system operates accordingly?</p>
<section id="whats-the-system" class="level2">
<h2 class="anchored" data-anchor-id="whats-the-system">What’s the system?</h2>
<p>The first question can be answered by understanding the business objective. We want customers to utilize our service for their food delivery needs. We promote our service by promising fast and accurate delivery right to their doors. Additionally, since our drivers are critical to the operations of this business, we want to keep our drivers as busy as possible to ensure they get the earnings they are seeking. Essentially, our business objective is to maintain optimal customer service to those who order while also providing good opportunities to our deliverers to make money. How can we optimize for both objectives simultaneously? Or rather, what system are we trying to control to fulfill this objective? <strong>The system we are aiming to control for Food-Ez is the queue</strong>. If we can control the queue in an optimal fashion, customers orders will be assigned quickly and be delivered quickly. Subsequently, if the queue is managed correctly, drivers objective of making good money will also be optimized. The queue is the system for which we will be designing a controller.</p>
</section>
<section id="what-should-we-feedback" class="level2">
<h2 class="anchored" data-anchor-id="what-should-we-feedback">What should we feedback?</h2>
<p>Now that we have identified what the system is, we can identify what elements of the system we should report back to the controller. If we are aiming to optimize the queue, we should report back elements that deal with queue health. Things like queue length, status of orders, status of drivers, location of dropoff and pickup, etc. The list below enumerates some of the crucial feedback elements we will provide to the controller.</p>
<ol type="1">
<li>Order Status (Pending, Assigned, En Route, Delivered)</li>
<li>Driver Status (Idle, Assigned, En Route, Delivered)</li>
<li>Order Location (Pickup Location, Dropoff Location)</li>
<li>Driver Location</li>
<li>Driver Assigned Orders</li>
</ol>
<p>For question two, we are essentially defining <strong>the states</strong> of important elements in our system. In control theory, this fundamental approach is known as providing state-space equations to understand how a system behaves. The formal equations are found in <a href="#eq-cont-1">Equation&nbsp;3.1</a>.</p>
<p><span class="math display">\[
\dot{\mathbf{x}}(t) = \mathbf{A}\mathbf{x}(t) + \mathbf{B}\mathbf{u}(t)
\]</span> <span id="eq-cont-1"><span class="math display">\[
\mathbf{y}(t) = \mathbf{C}\mathbf{x}(t) + \mathbf{D}\mathbf{u}(t)
\tag{3.1}\]</span></span></p>
<p>What <a href="#eq-cont-1">Equation&nbsp;3.1</a> says is that how the system changes <span class="math inline">\(\dot{x}(t)\)</span> at time <span class="math inline">\(t\)</span> is equal to the current states times the dynamics matrix <span class="math inline">\(A\)</span> plus the inputs <span class="math inline">\(u(t)\)</span> times input matrix <span class="math inline">\(B\)</span>. The output of the system is represented by <span class="math inline">\(y(t)\)</span> which depends on the current states of the system <span class="math inline">\(x(t)\)</span> times the output matrix <span class="math inline">\(A\)</span> plus the output matrix <span class="math inline">\(D\)</span> times the inputs <span class="math inline">\(u(t)\)</span>. Relating these equations back to our control diagram, the controller observes <span class="math inline">\(y(t)\)</span> and determines if this is suitable based on some predetermined baseline/reference. Based on that judgement, the controller sends back to the system <span class="math inline">\(u(t)\)</span>. This input and the current state of the system then “calculates” the next state of the system. This state is then used to produce the output <span class="math inline">\(y(t)\)</span> and the process repeats itself.</p>
<p>A golden example of this is cruise control in the car. The controller observes the speed of the car, measures it against the reference point (i.e.&nbsp;the set speed of cruise). The controller sends back to the system (the engine) the inputs to adjust the speed accordingly. These then are used to get the next state of the car (i.e.&nbsp;drag, gravity, etc) to then produce an output <span class="math inline">\(y(t)\)</span>.</p>
<p>While these explanations have been incredibly simplified, they produce the important principle that we can identify how to adjust the system in a closed-loop by providing important feedback to the controller on how a system is operating. In our scenario, we want to know where the drivers are, where they are going, where the food is, etc., in order to best know how to assign these orders in the queue to optimize the business objectives.</p>
</section>
<section id="what-actions-can-we-take-to-adjust-the-system" class="level2">
<h2 class="anchored" data-anchor-id="what-actions-can-we-take-to-adjust-the-system">What actions can we take to adjust the system?</h2>
<p>We identified the system and listed some information that would be useful for us to understand how the system is operating. We now need to provide actions that push our system optimized efficiency. In the previous section(s), we have identified the crux of this area. We need to assign orders to drivers such that orders get to their locations ASAP while also providing enough work to the drivers. There are several approaches to achieve this problem and they all have their own pros and cons. We could implement logic such we always assign the closest driver the order that comes in. Another approach would be holding orders for longer in the queue to see if a more “optimally” positioned driver comes along to take multiple orders nearby. Needless to say, we need sound strategy to idenfity which algorithmic process we should implement. For Food-Ez, it is optimizing the queue such that we minimize delivery time and maximize driver utilization (i.e.&nbsp;minimize driver idle time). Therefore, we need to design a controller that will balance these two objectives.</p>
</section>
</section>
<section id="establishing-operations" class="level1">
<h1>Establishing Operations</h1>
<p>Before getting into the controller logic, we’ll first walk through the operational flow of our system. This is illustrated in <a href="#fig-op-1">Figure&nbsp;4.1</a> (which is provided by <span class="citation" data-cites="doordash_optimization_2020"><a href="#ref-doordash_optimization_2020" role="doc-biblioref">[1]</a></span>).</p>
<div id="fig-op-1" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="https://doordash.engineering/wp-content/uploads/2020/08/life-cycle-12.jpg" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Figure&nbsp;4.1: Flow of operations for delivery services like DoorDash and Food-Ez</figcaption><p></p>
</figure>
</div>
<p>Walking through <a href="#fig-op-1">Figure&nbsp;4.1</a>, the process begins with a customer placing an order. The order is processed by the food delivery service and enters the queue. Returning to our control design, the queue would send pertinent information to the controller. The controller “analyzes” the information and sends its “suggested action” back to the queue. The queue then performs the actions by sending the orders to the correct restaurant (merchant) and the “optimal” deliverer (dasher). The order is then picked up by the deliverer and drops off the order to the customer.</p>
<p>Once again, we realize the importance of the “controller” in this system. The entirety of where the order is sent and who picks it up is determined by the controller. In the next sections, we’ll walk through the previous controller used and the new proposed controller logic.</p>
<section id="current-approach-bipartite-matching" class="level2">
<h2 class="anchored" data-anchor-id="current-approach-bipartite-matching">Current approach: bipartite matching</h2>
<p>The original logic followed by Food-Ez (and additionally DoorDash) was designed by framing the task as a bipartite matching problem. Essentially, the bipartite matching problem utilizes graph theory to split a network into 2 independent networks then assign each node from the first set to the second set, constrained on no two edges can have a common vertex. In the context of food delivery, this essentially means every order can only have 1 driver and every driver can only have 1 order. To do this efficiently to fulfill business objectives such as minimizing delivery time, problems like this can be solved using algorithms like the Hungarian algorithm <span class="citation" data-cites="kuhn1955hungarian"><a href="#ref-kuhn1955hungarian" role="doc-biblioref">[3]</a></span>.</p>
<p>While this approach fulfills the business objective, some simple examples illustrates the weaknesses of this approach. Suppose a deliverer is assigned an order and is heading to the restaurant. On the way, the driver passes another restaurant that just received an order that will be ready very soon. Furthermore, the dropoff location of this order is nearby the dropoff location of the first order. Instead of assigning this order to the driver, the system must assign another driver to this order. While more drivers are utilized in this approach, drivers could be used more efficiently.</p>
</section>
<section id="an-example-via-queue-theory" class="level2">
<h2 class="anchored" data-anchor-id="an-example-via-queue-theory">An example via queue theory</h2>
<p>To illustrate this, let’s pose the simple scenario of a single deliverer working for Food-Ez. Utilizing queue theory, we’ll assume this is a M/M/1 queue where the arrival process is modeled by a Poisson distribution with parameter <span class="math inline">\(\lambda = 1\)</span> (per hour), the service distribution is an exponential distribution with <span class="math inline">\(\mu = 2\)</span> (per hour), and there is a single server (deliverer).</p>
<p>With these metrics, we can calculate system utilization (or driver utilization in our case). This is defined as <span class="math inline">\(\rho = \frac{\lambda}{\mu}\)</span>, or the ratio between arrival rate and service rate. In our case, for a deliverer in the bipartite matching system, we get 50% driver utilization. While this is not bad, the average queue wait time for an order is defined as <span class="math inline">\(W_{q} = \frac{L_{q}}{\lambda}\)</span>, where <span class="math inline">\(L_{q}\)</span> is average length of queue. The average length of the queue here is .5 so in our scenario, queue wait time is about .5 hours or 30 minutes. Since our deliverer can only handle one order at a time, every order on average would have to wait 30 minutes in the queue.</p>
<p>In a different approach, let’s say a deliverer can now take two orders and assume it is no further than a 10 minute drive to complete. In this case, a deliverer can fulfill 2 orders in about 40 minutes (1 order / 30 mins was the rate before). Converting this to hours, a deliverer can now fulfill 3 orders per hour, thus chaning our deliverer utilization rate from 50% to 33%. More importantly, the queue wait time decreases from 30 minutes to 10 minutes (average queue length in this scenario is ~.167 orders, which is then divided by 1 order per hour). Not only could our drivers stay more busy if arrival rates increased, but our customers would have to wait only a third of the old time (if our simple assumptions hold)!</p>
</section>
</section>
<section id="optimizing-dispatch-using-integer-programming" class="level1">
<h1>Optimizing Dispatch using Integer Programming</h1>
<p>So far we have demonstrated from a high-level the current operations of Food-Ez, where a customer places an order, the controller (using a dispatch algorithm) matches orders to restaurants and deliverers to orders such that we minimize delivery time from order placement to order delivery. In order to accomodate other business objectives, we need a new optimization framework for our dispatch algorithm. Once we implement that, we can substitute the current dispatch algorithm for the newly enhanced one and it should fit into our control design seamlessly. Our proposed solution for accomodating multiple business objectives is <strong>integer programming with a weighted sum score</strong> <span class="citation" data-cites="Gomory1958"><a href="#ref-Gomory1958" role="doc-biblioref">[4]</a></span> (Note: <span class="citation" data-cites="doordash_optimization_2020"><a href="#ref-doordash_optimization_2020" role="doc-biblioref">[1]</a></span> uses a mixed integer program approach due to the more complex and wholistic approach to addressing the dispatch problem, but for our simple scenario, we reduce the problem to an integer program). Our formulation is found in <a href="#eq-int-1">Equation&nbsp;5.1</a>.</p>
<p><span class="math display">\[
min \sum_{i=1}^{N}\sum_{j=1}^{D} c_{ij}x_{ij}
\]</span> <span class="math display">\[
\sum_{j=1}^{D} x_{ij} = 1 \; \forall i \in N
\]</span> <span class="math display">\[
\sum_{i=1}^{N} x_{ij} \le 2 \; \forall j \in D
\]</span> <span id="eq-int-1"><span class="math display">\[
c_{ij} = \sum_{m=1}^{W} w_{m}p_{m}
\tag{5.1}\]</span></span></p>
<p>Let <span class="math inline">\(N\)</span> be the set of orders that need assignment and let <span class="math inline">\(D\)</span> be the set of potential drivers that can perform the order. Furthermore, we filter <span class="math inline">\(N\)</span> and <span class="math inline">\(D\)</span> by saying we will only consider orders that haven’t been assigned (order can only be assigned and accepted once) and a driver can only be considered if it contains less than 2 orders. Once we have our viable sets, we attempt to minimize the cost function (objective function) where <span class="math inline">\(c_{ij}\)</span> is the cost associated with assigning the <span class="math inline">\(ith\)</span> order to the <span class="math inline">\(jth\)</span> driver. <span class="math inline">\(x_{ij}\)</span> is the decision variable in our program, which is a binary variable of whether we assign the <span class="math inline">\(ith\)</span> order to the <span class="math inline">\(jth\)</span> driver. The cost associated with each order is determine by the last line of <a href="#eq-int-1">Equation&nbsp;5.1</a>, where we define the cost as a weighted sum of different predictors. In our scenario with Food-Ez, we define four key variables below.</p>
<ol type="1">
<li>Route Time (total time duration of driver arriving to restaurant, picking up the order, and dropping off the order)</li>
<li>Wait Time (total prep time of the order)</li>
<li>Drive Acceptance (probability of a driving accepting an order)</li>
<li>Driver Idleness (binary of whether or not driver has any orders or no)</li>
</ol>
<p>This new approach allows us to determine which of our four factors are most pressing for our current business needs since we can adjust the weights of these accordingly and allow the objective function to recognize those changes. For the complete code up of our algorithm, see the <a href="https://github.com/thebayesianbandit/thebayesianbandit.github.io/blob/main/posts/dispatch_alg/dispatch_alg.ipynb">github repo</a>.</p>
</section>
<section id="simulation-results" class="level1">
<h1>Simulation Results</h1>
<p>We have successfully defined a new approach for our Food-Ez dispatch algorithm. To see how it would do in “real-life” scenarios, we designed a simulation to test our algorithm. We ran 5 simulations for 120 iterations (120 simulation “minutes”). The simulation parameters consist of the following: number of drivers (which we hold constant throughout), number of restaurants, grid size of city, order arrival rate, route time weight, wait time weight, driver acceptance weight, and driver idleness weight. Each simulation with their respective parameters are found below.</p>
<ol type="1">
<li>Simulation(10, 10, 5, 1, .5, .2, .1, .2)</li>
<li>Simulation(5, 10, 5, 1, .5, .2, .1, .2)</li>
<li>Simulation(10, 10, 5, 1, .05, .7, .05, .2)</li>
<li>Simulation(10, 10, 5, 1, .25, .25, .25, .25)</li>
<li>Simulation(10, 10, 5, 1, .8, .05, .1, .05)</li>
</ol>
<p>For example, simulation 1 has 10 drivers with 10 restaurants, a city that is 5x5 units, an order arrival rate of 1 (per minute), .5 weight on route time, .2 weight on wait time, .1 weight on driver acceptance, and .2 weight on driver idleness. The results of each simulation is found below in <a href="#tbl-res-1">Table&nbsp;6.1</a>. (Note: we ran each simulation with the same random seed settings for consistency in comparison).</p>
<div id="tbl-res-1" class="anchored">
<table class="table">
<caption>Table&nbsp;6.1: Simulation Results</caption>
<colgroup>
<col style="width: 6%">
<col style="width: 4%">
<col style="width: 4%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 5%">
<col style="width: 11%">
<col style="width: 11%">
<col style="width: 10%">
<col style="width: 11%">
<col style="width: 13%">
<col style="width: 9%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Simulation</th>
<th style="text-align: center;">Orders</th>
<th style="text-align: center;">Pending</th>
<th style="text-align: center;">Assigned</th>
<th style="text-align: center;">En Route</th>
<th style="text-align: center;">Delivered</th>
<th style="text-align: center;">Avg Driver Wait Time</th>
<th style="text-align: center;">Avg Driver Idle Time</th>
<th style="text-align: center;">Avg Time To Pickup</th>
<th style="text-align: center;">Avg Time To Dropoff</th>
<th style="text-align: center;">Avg Time Of Total Route</th>
<th style="text-align: center;">Avg Time Pending</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">112</td>
<td style="text-align: center;">21.50</td>
<td style="text-align: center;">59.50</td>
<td style="text-align: center;">6.78</td>
<td style="text-align: center;">1.73</td>
<td style="text-align: center;">8.52</td>
<td style="text-align: center;">0.40</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">113</td>
<td style="text-align: center;">71.40</td>
<td style="text-align: center;">2.80</td>
<td style="text-align: center;">6.00</td>
<td style="text-align: center;">1.00</td>
<td style="text-align: center;">7.00</td>
<td style="text-align: center;">0.00</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">112</td>
<td style="text-align: center;">53.20</td>
<td style="text-align: center;">41.30</td>
<td style="text-align: center;">6.24</td>
<td style="text-align: center;">1.13</td>
<td style="text-align: center;">7.38</td>
<td style="text-align: center;">0.42</td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">112</td>
<td style="text-align: center;">31.90</td>
<td style="text-align: center;">51.00</td>
<td style="text-align: center;">6.32</td>
<td style="text-align: center;">1.64</td>
<td style="text-align: center;">7.96</td>
<td style="text-align: center;">0.25</td>
</tr>
<tr class="odd">
<td style="text-align: center;">5</td>
<td style="text-align: center;">120</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">111</td>
<td style="text-align: center;">19.40</td>
<td style="text-align: center;">61.00</td>
<td style="text-align: center;">6.73</td>
<td style="text-align: center;">1.76</td>
<td style="text-align: center;">8.50</td>
<td style="text-align: center;">0.32</td>
</tr>
</tbody>
</table>
</div>
<p>From <a href="#tbl-res-1">Table&nbsp;6.1</a>, the number of deliveries performed appear to be the same even with the change of parameter weights. This is a nice observation since simulation 2 had half of the drivers that the other simulations had, but delivered the most orders. Furthermore, simulation 2 shows that drivers were used efficiently as most drivers were only idle for on about 3 minutes on average, compared to the other simulations that had far more idle time. We continue to see this trend in other metrics for simulation 2. Simulation 2 had the lowest average time to dropoff, lowest average time of total route, and even lowest pending time for orders in the queue. Further investigation is needed to see what the optimal driver supply would be in different scenarios, but this is a telling sign at the moment that our new algorithm utilizes driver supply more efficiently.</p>
<p>There are many other interesting findings from these 5 simulations, but we will leave these to the reader to discover.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>In this post, we presented a business case where a food-delivery company, Food-Ez, is looking to optimize their dispatch algorithm to accomodate more business objectives. We then walked through how this problem can be designed as a control problem and identified the system to be controlled, the feedback data needed to control it, and how to design our controller. Our controller in this scenario ended up being the dispatch algorithm to more efficiently assign orders by raising the limit on orders a driver can carry along with other business objectives within our objective function. To do this, we changed our algorithm foundation from a bipartite matching problem to an integer programming program. We formulated how we would minimize this new objective function and designed a simulation to demonstrate the usefulness of it. Next steps would include further simulations with more “real-world” dynamics involved and potential experimentation using things like switchback experiments. Overall, we hope this post demonstrated key frameworks that one can use in designing real-world applications to enhance operational efficiency for businesses.</p>



</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body" role="list">
<div id="ref-doordash_optimization_2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">Holly Jin, <span>“<span class="nocase">Next-Generation Optimization for Dasher Dispatch at DoorDash</span>,”</span> <em><span>DoorDash Engineering Blog</span></em>, 2020.</div>
</div>
<div id="ref-weinstein_ml_optimization_2021" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">Alex Weinstein, <span>“<span class="nocase">Using ML and Optimization to Solve DoorDash’s Dispatch Problem</span>,”</span> <em><span>DoorDash Engineering Blog</span></em>, 2021.</div>
</div>
<div id="ref-kuhn1955hungarian" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">H. W. Kuhn, <span>“The hungarian method for the assignment problem,”</span> <em>Naval Research Logistics Quarterly</em>, vol. 2, no. 1–2, pp. 83–97, 1955.</div>
</div>
<div id="ref-Gomory1958" class="csl-entry" role="listitem">
<div class="csl-left-margin">[4] </div><div class="csl-right-inline">R. E. Gomory, <span>“Outline of an algorithm for integer solutions to linear programs,”</span> <em>Bulletin of the American Mathematical Society</em>, vol. 64, no. 5, pp. 275–278, 1958.</div>
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>